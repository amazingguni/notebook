# 10.1 파일 개념

파일은 운영체제에 의하여 정의되고 구현되는 추상적인 자료형이다.

- 사용자 관점에서 볼 때 파일은 논리적 보조 저장장치의 가장 작은 할당 단위이다.
- 파일은 논리 레코드의 연속으로써, 바이트, 행 또는 좀 더 복합적인 자료 항목들이다.
- 파일은 운영체제에 의해 물리 장치들로 맵핑된다.
- 운영체제는 구체적으로 다양한 레코드형을 사용자에게 제공하거나 운영 프로그램의 몫으로 남긴다.

운영체제의 가장 중요한 임무는 논리적인 파일 개념을 자기테이프나 디스크 같은 물리 저장장치로 맵핑시키는 것이다. 

- 물리 레코드의 크기는 논리 레코드 크기와 일치하지 않기 때문에 논리 레코드를 물리 레코드에 정리 배치 시켜야 한다.

## 10.1.1 파일 속성

파일은 만들어지면 그 파일을 생성한 프로세스, 사용자, 시스템으로부터 독립하게 된다.

- 다른 프로세스, 사용자도 읽고 수정할 수 있다.

파일은 다음 속성들을 공통적으로 갖는다.

1. 이름
2. 식별자
3. 타입
4. 위치
5. 크기
6. 보호
7. 시간, 날짜, 사용자 식별

모든 파일에 대한 정보는 보조 저장장치에 상주하는 디렉토리 구조 내에 유지된다.

- 디렉토리는 파일의 이름과 고유의 식별자로 구성된다.
- 이 식별자는 파일 속성들을 찾는데 사용된다.

## 10.1.2 파일 연산

파일 조작에 필요한 최소 연산은 아래 6개가 있다.

1. 파일 생성
2. 파일 쓰기
3. 파일 읽기
4. 파일 안에서의 위치 재설정 - seek
5. 파일 삭제
6. 파일 절단 - 파일의 속성은 남기고 내용을 지움, 파일 길이만 0으로 변경한다.

위의 것들을 조합해 더 많은 파일 조작 연산을 구현할 수 있다.

대부분의 시스템은 파일이 맨 처음 사용되기 전에 open을 호출하게 한다.

- 이 연산이 불리면 파일 이름으로 디렉터리를 찾고 해당 항목을 열린 파일의 테이블로 복사한다.
- 이 과정에서 허가된 모드를 만족하는지 보고 아닐 경우 에러를 발생시킨다.
- 테이블에 추가한 이후에 해당 항목에 대한 포인터를 되돌려 준다.
- 이후 이 포인터를 연산에 사용함으로써 더이상의 탐색을 피한다.

여러 프로세스에서 동시에 파일에 접근할 수 있기 때문에 프로세스별 테이블의 각 항목은 다시 범 시스템 오픈 파일 테이블을 가리키게 된다.

- 시스템 테이블은 디스크 상의 파일 위치, 접근 날짜, 파일 크기 등의 정보도 가지고 있다.
- 일반적으로 이 테이블은 파일을 연 프로세스의 수를 가리키는 오픈 계수도 항목에 가지고 있다.
- 오픈 계수가 0이 되면 해당 항목을 제거한다.

열린 파일과 관련한 정보

1. 파일 포인터
	- read, write 시에 현재 파일 위치를 가리키는 포인터는 각 프로세스에 대해 하나씩 있어야 한다
2. 파일 오픈 계수
	- 시스템에 열린 파일과 각 항목을 오픈한 프로세스의 계수를 가지고 있어야 한다.
3. 파일의 디스크 위치
	- 대부분의 파일 연산들은 시스템에게 파일 내의 데이터를 변경하라고 요구한다.
	- 디스크 상의 파일의 위치를 찾기 위한 정보는 메모리에 저장된다.
4. 접근 권한

몇몇 운영체제는 열려진 파일을 잠금할 수 있는 기능을 제공한다.

- 한 프로세스가 잠그고 다른 프로세스들이 접근하지 못하도록 하는 것
- 시스템 로그파일과 같이 공유되는 파일들에 유용하다

파일 잠금은 읽기-쓰기 잠금과 유사한 기능을 제공한다.

- 공유 잠금 - 여러 프로세스가 동시에 잠금을 획득할 수 있다 - 읽기 잠금과 유사
- 베타적인 잠금 - 한번에 한 프로세스만 잠금을 획득할 수 있다 - 쓰기 잠금과 유사

## 10.1.3 파일 타입

운영체제 설계 시 중요한 점 중 하나는ㄴ 운영체제가 파일 타입들을 인식하고 지원할 것인지를 결정
하는 것이다.

- 확장자로 구성된 파일 이름을 사용할 수 있다.
- Mac의 경우 creator로 프로그램을 갖는다.(실행시 해당 프로그램이 적재된다)
- Unix는 파일의 맨 앞에 magic number를 넣고 그에 따라 동작하도록 한다.(강제적이진 않음)

## 10.1.4 파일 구조

파일은 다음과 같이 내부 구조를 가진다.

- 운영체제가 인식할 수 있는 구조를 따름
	- 운영체제가 여러 파일 구조를 지원하면 운영체제의 크기가 증가함
- UNIX는 파일을 8비트 바이트들의 단순한 집합으로 보기에 의미를 운영체제가 해석하지 않는다.
	- 대신 응용프로그램이 해석하고 운용한다.
	- 그래도 실행 파일의 구조는 지원한다.
- 매킨토시도 최소한의 파일 구조를 지원한다.
	- 파일이 리소스 포크와 데이터 포크로 나눠진다.

## 10.1.5 파일의 내부 구조

디스크 시스템은 보통 섹터의 크기에 의해 결정되는 블록 크기를 가진다.

- 모든 디스크 I/O는 한 블록 단위(물리적인 레코드)로 실행되며, 모든 블록은 동일한 크기를 갖는다.
- 물리 레코드의 길이는 원하는 논리 레코드의 크기와 보통 일치하지 않는다
	- 따라서 여러 논리 레코드를 하나의 물리 레코드에 팩킹해야 한다.
	- UNIX의 경우 논리 레코드는 1바이트이다.
	- 파일 시스템은 자동으로 바이트를 하나의 물리 블록(예를 들면 블록 당 512바이트)로 팩킹한다.
- 디스크는 I/O 기능을 블록 단위로 실행한다.
	- 블록의 크기가 클 수록 더 큰 내부 단편화가 일어날 수 있다.

# 10.2 접근 방법

## 10.2.1 순차 접근

파일의 정보가 레코드 순서대로 차례차례 처리된다.

- 편집기나 컴파일러는 이런 방식으로 접근한다.
- 읽기는 파일의 다음 부분을 차례로 읽어나감
- 쓰기는 파일의 끝에 추가하며 새로운 파일의 끝으로 파일 포인터가 이동함
- 어떤 시스템에서는 프로그래머가 오프셋을 정수 n개의 레코드만큼 뛰어 넘어갈 수 있다.

## 10.2.2 직접 접근

직접 접근을 위해서 파일은 고정 길이의 논리 레코드들로 구성되고 특별한 순서 없이 빠르게 레코드를 읽고 쓸 수 있다.

- 디스크가 무작위 파일 블록에 임의적 접근을 허용하기 때문에 가능한 기능이다.
- 직접 접근을 위해 파일은 번호를 갖는 일련의 블록 또는 레코드로 간주된다.

직접 접근 파일은 대규모의 정보를 즉각적으로 접근하는 데 아주 유용하다.

- 데이터 베이스가 이러한 유형이다.

직접 접근 방식을 위해서는 파일 연산이 블록 번호 파라미터를 포함할 수 있도록 수정되어야 한다.

- read next -> read n
- write next -> write n

사용자가 운영체제에게 제공하는 블록 번호는 보통 파일의 시작을 0으로 보고 계산한 레코드의 위치로써 상대 블록 번호이다.

- 상대 블록 번호를 사용하기 위해서는 운영체제가 파일이 어디에 저장되어야 하는지를 결정해야만 한다. -> 이는 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 막는데 도움이 된다.

현재 위치를 가리키는 변수 cp만 유지한다면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 제공할 수 있다.

- 반대는 가능하지만 매우 비효율적이다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_05_SequentialAccessSimulation.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_05_SequentialAccessSimulation.jpg)

## 10.2.3 기타 접근 방법

색인을 통해 접근할 수 있다.

파일에서 레코드를 찾기 위해서 색인부터 찾아 그에 대응하는 포인터를 얻고, 그를 통해 파일에 직접 접근한다.

# 10.3 디렉터리와 디스크 구조

파티션은 

- 개별 파일 시스템의 크기를 제한하거나, 
- 하나의 디스크에 여러 개의 파일 시스템을 사용하거나, 
- 파일 시스템으로 일부분을 사용하고 나머지 부분은 스왑 공간이나 포맷되지 않은 디스크 공간 같은 것으로 사용할 때 유용하다.

파일 시스템을 포함하고 있는 임의의 파티션을 Volume이라고 부른다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_07_TypicalFileSystem.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_07_TypicalFileSystem.jpg)

- 볼륨은 논리적인 가상 디스크로 취급할 수 있다.
- 볼륨은 하나 이상의 운영체제를 부팅하고 실행할 수 있다
- 파일 시스템을 포함하고 있는 각 볼륨은 시스템에 존재하는 파일에 대한 정보 역시 가지고 있어야 한다.
	- **디바이스 디렉터리**, 콘텐츠 볼륨 테이블의 항목에 저장된다.
	- 디바이스 디렉터리는 그 볼륨에 있는 모든 파일에 대한 이름, 위치, 크기, 타입과 같은 정보를 기록한다.

## 10.3.1 저장장치의 구조

범용 컴퓨터 시스템은 다수의 저장장치를 가지고 있고, 그 장치들은 파일 시스템을 저장할 수 있는 볼륨으로 분할될 수 있다.

## 10.3.2 디렉터리 개관

디렉터리는 **파일 이름을 해당 디렉터리 항목으로 변환해주는 심벌 테이블** 로 볼 수 있다.

특정한 디렉토리 구조를 고려할 때 각 디렉터리에는 다음 연산이 필요하다.

1. 파일 찾기
2. 파일 생성 - 새로운 파일들을 생성해 디렉터리에 추가
3. 파일 삭제
4. 디렉터리 나열 - 디렉터리에 존재하는 파일들을 나열하고, 각 파일에 대한 디렉터리 항목의 내용을 보여준다.
5. 파일의 재명명
6. 파일 시스템 순회

## 10.3.3 1단계 디렉터리


가장 간단한 디렉터리 구조가 1단계 디렉터리이다.

- 모든 파일이 디렉터리 밑에 존재하기 때문에 지원하기도 이해하기도 쉽다.
- 유일한 이름을 가져야 하기에 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 문제가 생길 수 있다.
	- 같은 디렉토리에 모든 파일이 존재하므로 유일한 이름을 짓기 쉽지 않다.
	- 또, 그 유일한 이름을 기억하기도 어렵다

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_09_SingleLevel.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_09_SingleLevel.jpg)

## 10.3.4 2단계 디렉터리

2단계 디렉터리는 사용자마다 독자적인 디렉터리를 할당함으로써 이 문제를 해결한다.

- 각 사용자는 자신만의 사용자 파일 디렉터리(User File Directory)를 가진다.
- 사용자 작업이 시작되거나 시스템에 사용자가 로그인하면 마스터 파일 디렉터리(Master File Directory)가 먼저 탐색된다.
	- MFD는 사용자 이름이나 계정 번호로 색인되어 있고, 각 엔트리는 해당 사용자의 UFD를 가리키고 있다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_10_TwoLevelStructure.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_10_TwoLevelStructure.jpg)

사용자가 특정한 파일을 참조하면 사용자의 UFD에서만 탐색한다.

- 그러므로 유저간에 동일한 이름의 파일을 가질 수 있다.

특수 시스템 프로그램을 통해서 사용자 파일 디렉토리를 추가/삭제한다.(시스템 관리자)

이 구조는 사용자 별 디렉토리 구조를 가질 수 있어 이름 충돌 문제를 피할 수 있다.

- 각 사용자의 디렉토리가 격리되어 다른 사용자의 파일을 접근할 수 없다.

다른 사용자의 디렉토리에 접근하려면 다른 디렉토리의 파일을 지칭하기 위한 syntax가 있어야 한다.

- /user/test, C:\userb\test 등

## 10.3.5 트리 디렉토리

2단계 디렉터리를 자연스럽게 일반화시키면 트리 구조 디렉터리가 된다.

- 하나의 루트 디렉토리를 가진다.
- 트리 구조 디렉터리는 사용자가 파일을 구성하기 위하여 하위 디렉터리를 생성하는 것을 허용한다.
- 시스템의 모든 파일은 고유한 경로 이름을 가진다.

디렉토리는 파일과 서브 디렉터리의 집합을 포함한다.

- 모든 디렉토리들은 한 비트를 사용해 그 항목이 나타내는 파일이 일반 파일(0)인지 디렉터리 파일(1)인지를 구분한다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_11_TreeStructure.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_11_TreeStructure.jpg

## 10.3.6 비순환 그래프 디렉터리

사이클이 없는 비순환 그래프는 디렉터리들이 서브디렉터리들과 파일들을 공유할 수 있도록 허용한다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_12_AcyclicGraph.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_12_AcyclicGraph.jpg)

공유 파일(디렉토리)는 여러 방법으로 구현 가능하다.

- link라 불리는 새로운 디렉터리 항목을 만드는 것
- link는 다른 파일이나 서브 디렉토리를 가리키는 포인터
- 절대 혹은 상대 경로명으로 구현될 수 있다.
- 파일에 대한 참조가 일어날 때 디렉토리 항목이 link이면 실제 파일 이름은 링크 정보에 포함되어 있다.
- 운영체제가 디렉터리 트리를 순회할 때는 link를 무시한다.

비순환 그래프 디렉터리 주고는 단순한 트리 구조보다는 융통성이 있는 대신 더 복잡하다.

- 파일 시스템을 순회할 때 공유 파일/디렉토리를 한 번 이상 순회하게 될 수도 있다.
- 원본이 삭제되면 존재하지 않는 파일을 가리키는 대상이 없는 포인터를 남긴다.

심벌릭 링크로 공유를 구현하는 경우에는,

- 심벌릭 링크를 지우는 건 원본 파일에는 영향을 미치지 않고
- 파일을 지웠을 때는 대상 없는 포인터가 된다.

하드 링크의 경우에는,

- 파일 정보 블록에 참조 계수를 추가하고
- 하드 링크가 모두 삭제된 이후에 파일을 삭제한다.

## 10.3.7 일반 그래프 디렉토리

트리구조 디렉토리에 링크가 생기게 되면, 사이클이 생길 수도 있다.

그러면 탐색시에 무한 루프에 빠질 수도 있다.

- 이를 해결하기 위해 엑세스하는 디렉터리의 개수를 임의로 제한할 수 있음

파일을 언제 삭제할 수 있는지 결정할 때에도 유사한 문제가 발생한다.

- 비순환 그래프의 경우 참조계수가 0이라는 것이 삭제해도 된다는 것을 의미하지만
- 순환이 존재하면 참조되지 않더라도 참조 계수가 0일 아닐 수 있다.(순환으로 인해)

따라서 가비지 컬렉션을 가동한다. -> 시간이 많이 들어 거의 사용하지는 않음

1. 전체 파일 시스템을 순회하여 접근 가능한 모든 것을 표시한다.
2. 두번째 탐색에서 표시되지 않은 것들을 사용가능한 공간 리스트에 추가한다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_13_GeneralGraph.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter11/11_13_GeneralGraph.jpg)

# 10.4 파일 시스템 마운팅

디스크는 하나 이상의 볼륨으로 나눠지며 각 볼륨은 미가공 상태이거나 하나의 파일 시스템을 포함한다.

각 볼륨들이 마운트 되어야 파일 시스템 지명 공간에서 이용 가능하다

- 지명 구조는 운영체제마다 다르다.
- 마운트되면 볼륨 내의 파일들이 사용 가능해진다.
- 파일 시스템은 접근을 금지시키거나 유지보수를 위해 언마운트될 수 있다.

마운트 과정은 다음과 같다

1. 운영체제는 디바이스 이름과 마운트 포인트(파일 시스템을 부착할 수 있는 파일 구조 내의 위치)를 전달받는다.
	- 몇몇 운영체제는 파일 시스템의 유형이 제공되어야 하고, 다른 것들은 검사하여 결정한다.
	- 마운트 포인트는 보통 비어있는 디렉터리이다.
2. 디바이스가 유효한 파일 시스템을 포함하는지 검증한다.
	- 디바이스 드라이버에게 디바이스 디렉터리를 읽도록 요청한다
	- 읽혀진 디렉터리가 유효한 포멧인지를 검증한다.
3. 지정된 마운트 포인트에 파일 시스템이 마운트되었음을 디렉터리 구조에 기록한다.

# 10.5 파일 공유

## 10.5.1 다수의 사용자

파일 공유와 보호를 구현하기 위해 시스템은 단일 사용자 시스템에서 유지하는 것보다 더 많은 파일과 디렉터리 속성을 유지해야 한다.

- 파일/디렉터리의 소유자, 그룹이라는 개념 사용
- 소유자는 파일 속성을 변경하거나 파일에 대한 접근을 허가하고 가장 많은 제어 권한을 가지고 있는 사용자
- 소유자가 그룹 멤버, 기타 사용자가 어떤 연산을 할 수 있는지 정의한다.

사용자가 파일 연산을 요구할 때 시스템은 결정된 허가와 요구된 연산을 비교해 허가하거나 거부한다.

## 10.5.2 원격 파일 시스템

1. FTP를 통해 기계간에 파일을 직접 전송
2. 분산 파일 시스템(DFS)을 사용해 원격 디렉터리에 접근
3. WWW - 브라우저로 별도의 연산을 사용(FTP와 유사)

DFS는 원격 파일에 접근하는 기계와 그 파일을 제공하는 기계 사이에 더 긴밀한 통합을 가진다.

### 10.5.2.1 클라이언트 서버 모델

서버는 클라이언트에게 자원이 사용 가능함을 공지한다.

- 여기서 어느 자원(파일)인지와 어느 클라이언트의 접근을 허용할지를 명시한다.
- 서버는 대개 볼륨이나 디렉토리 수준에서 사용 가능한 파일을 명시한다.

클라이언트는 이 자원을 이용하게 된다.

네트워크 파일 시스템(NFS)의 경우 디폴트로 클라이언트 네트워킹 정보를 통해 인증을한다.

- 사용자 ID가 클라이언트와 서버에서 일치해야 한다. 
- 그렇지 않으면 서버는 파일에 대한 접근 권한을 결정할 수 없다.

원격 파일 시스템이 마운트되면, 파일 연산 요청은 사용자를 대신하여 DFS 프로토콜을 통해 네트워크를 거쳐 서버로 보내진다. 

- 일반적으로 파일 열기 요청은 사용자의 ID와 함께 보내진다.
- 서버는 사용자가 요청된 모드로 파일에 접근할 수 있는 자격을 가지고 있는지 결정하기 위해 표준 접근 검사를 적용한다.

### 10.5.2.2 분산 정보 시스템

클라이언트-서버 시스템을 쉽게 관리하기 위해 분산 정보 시스템(분산 네이밍 서비스)가 원격 컴퓨팅을 위해 필요한 정보에 단일화된 접근을 제공한다.

- DNS는 그 중 하나이며, 전체 인터넷의 호스트 이름을 네트워크 주소로 변환해주는 서비스를 제공한다.
- 이전에는 모든 네트워크 호스트 간에 이메일이나 ftp를 사용하여 보내졌다.

다른 분산 정보 시스템은 분산 설비를 위해 사용자 이름/패스워드/사용자ID/그룹ID 공간을 제공한다.

- 윈도우에서는 이를 위해 예전에는 도메인, 현재는 활성 디렉터리(active directory)를 제공한다.
- LDAP도 동일한 기능을 제공한다.
- 사용자는 자신의 인증 정보를 입력함으로써 조직 내의 모든 컴퓨터를 액세스할 수 있다.

### 10.5.2.3 고장 모드

원격 파일 시스템은 고장 상황의 처리를 정의하고 구현해야 한다.

- 고장이 생겼을 때 연산을 연기시키거나 실행시키도록 구현하기도 한다.

# 10.6 보호

우리는 정보가 물리적인 손상(신뢰성)과 부적절한 접근(보호)으로부터 안전하게 유지되길 원한다.

1. 신뢰성은 파일의 복사본에 의해 제공된다.
	- 많은 컴퓨터는 파일 시스템이 파괴될 경우를 대비하여 규칙적으로 복사본을 마련한다.
2. 보호 방법은 여러가지가 있을 수 있다.

## 10.6.1 접근의 타입

우리에게 필요한 것은 통제된 접근이다.

보호 기법은 파일 접근 타입을 제한함으로써 통제된 접근을 제공한다.

- 읽기, 쓰기, 실행, 추가, 삭제, 리스트

## 10.6.2 접근 제어

파일과 디렉터리에 접근 제어 리스트(Access-Control List, ACL)을 연관해두어 접근을 제어한다.

- 사용자 이름과 허용된 접근 유형을 명시한다.
- 사용자가 특정 파일에 대한 접근을 요청할 때 운영체제는 그 파일의 접근 리스트를 검사하여 허용 여부를 결정한다.

접근 제어 리스트를 사용하면 파일별로 사용자 리스트를 구축해야 하는 문제가 생긴다.

따라서 접근 리스트의 길이를 압축해 3가지로 분류한다.

1. 소유자
2. 그룹
3. 모든 사람

유닉스에서는 각 3비트인 3필드로 접근 권한을 정의한다.

- rwx
- read, write, execute
- 소유자, 소유자의 그룹, 모든 사용자
- 이 방법에서는 파일당 9비트가 필요하다

보통은 압축된 버전의 접근 리스트를 기본으로 ACL로 등록된 사용자가 있다면 우선순위를 제공한다.

## 10.6.3 기타 보호 방법

파일(디렉토리)마다 암호를 연결시킨다.

- 암호가 무작위로 선택되고 자주 변경된다면 효과적일것이다.

하지만..

1. 암호의 수가 많아지면 현실적으로 사용 불가능
2. 모든 파일에 대해 하나의 암호를 쓸 경우 모든 파일에 접근 가능



