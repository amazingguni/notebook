# 11.1 파일 시스템 구조
 
입출력 효율을 향상시키기 위해 메모리와 디스크간의 입출력 전송은 블록 단위로 실행된다.

- 각 블록은 하나 이상의 섹터를 가지며, 하나의 섹터는 통상 512바이트이다.

**파일 시스템**은 쉽게 데이터를 저장하고, 찾고 또한 인출할 수 있게 함으로써 디스크를 보다 효율적이고 편리하게 사용할 수 있게 한다.

- 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의한다.
	- 파일과 속성, 파일에 허용된 연산, 파일을 정리하기 위한 디렉터리 구조를 정의하는 것을 포함
- 논리 파일 시스템을 물리적인 2차 저장장치로 맵핑하는 알고리즘과 자료 구조를 고안하는 것

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_01_LayeredFileSystem.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_01_LayeredFileSystem.jpg)


**입출력 제어**는 장치 드라이버와 인터럽트 핸들러로 이루어져 있고 메모리와 디스크 시스템간의 정보 전송을 담당한다.

- **장치 드라이버**는 물리적 장치를 조작한다.
- 블록 123을 검색하라 같은 고수준의 명령을 하드웨어에 맞는 저수준의 명령으로 번역해 제어한다.

**기본 파일 시스템**은 적절한 장치 드라이버에게 디스크 상의 물리 블록을 읽고 쓰도록 일반적인 명령을 내리는 층이다.

- 이때 각 디스크 블록은 숫자로 표시된 디스크 주소에 의하여 식별된다.
- 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시 관리도 포함한다.

**파일-구성 모듈** 은 물리 블록 뿐만 아니라 파일과 파일의 논리 블록도 알고 있다.

- 사용 중인 파일 할당의 타입과 파일의 위치를 알고 있기 때문에 이 모듈은 논리 블록 주소를 물리 블록 주소로 변환할 수 있다.
- 각 파일의 논리 블록은 0~N까지 번호가 매겨진다.
- 가용 공간 관리자도 포함하고 있다.

**논리 파일 시스템**은 메타 데이터 정보를 관리한다.

- 메타 데이터는 실제 데이터 또는 파일의 내용을 제외한 모든 파일 시스템 구조를 포함한다.
- 디렉토리를 관리하고, 심벌릭 이름이 주어진다.
- 파일 구성 모듈이 필요한 정보를 제공한다.
- 파일 구조는 파일 제어 블록(FCB)을 통해 유지된다.
	- 소유, 허가, 위치 등
	- 유닉스에서는 inode로 구현
- 보호와 보안을 책임진다.
 
# 11.2 파일 시스템 구현

파일 시스템 연산을 구현하는 데 사용되는 구조와 연산에 대해 깊이 살펴본다.

## 11.2.1 개요

간단하게 파일 시스템을 구현하는데 사용되는 디스크 상의 구조와 메모리 내 구조가 파일 시스템을 설명하도록 한다.

디스크에 존재하는 파일 시스템은 부팅 방법, 볼륨 내 블록의 정보 등의 정보를 가지고 있다.

1. 부트 제어 블록
	- 시스템이 볼륨으로부터 운영체제를 부트시키기 위해 필요한 정보를 가지고 있다.
	- 운영체제가 없다면 비어 있을 것이다.
	- 일반적으로 볼륨의 첫 번째 블록
2. 볼륨 제어 블록
	- 볼륨의 블록 수, 블록의 크기, 
	- 가용 블록의 수와 포인터, 가용 FCB 수와 포인터
	- 그 외 상세한 볼륨 정보를 가진다.
3. 디렉터리 구조는 파일 시스템마다 존재하며 파일을 조직하는 데 사용된다.
	- 디렉터리 구조에 파일 이름 및 해당 inode 번호가 저장된다.
4. 파일별 FCB는 자세한 파일 정보를 가지고 있다.
	- 디렉터리 항목과의 연결을 위한 고유한 식별 번호
	- inode number, permission, size, dates

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_02_FileControlBlock.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_02_FileControlBlock.jpg)

메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다.

- 이 정보들은 마운팅 시점에 적재되고, 파일 시스템 동작 중에 갱신되며, 마운트 해제 시에 제거된다.

1. 메모리 내 마운트 테이블은 각 마운트된 볼륨 정보를 포함한다.
2. 메모리 내 디렉터리 구조 캐시는 최근 접근된 디렉터리의 디렉터리 정보를 유지한다.
3. 범시스템 열린 파일 테이블
4. 프로세스별 열린 파일 테이블
5. 버퍼는 파일 시스템이 디스크로부터 읽혀지거나 써질 때 파일 시스템 블록을 저장한다.

open() 호출은

1. 우선 파일이 이미 다른 프로세스에 의해 사용 중인지 확인하기 위하여 범 시스템 오픈 파일 테이블을 검색한다.
2. 사용 중이면,
	1. 기존 범 시스템 오픈 파일 테이블을 가리키는 프로세스별 오픈 파일 테이블 항목이 생성된다.
3. 오픈되지 않았다면 
	1. 주어진 파일 이름을 디렉터리 구조에서 찾는다.
		- 디렉터리 연산의 속도를 향상시키기 위해 통상 디렉토리 구조의 일부를 메모리에 캐싱한다.
	2. 파일이 발견되면 FCB가 메모리 내의 범 시스템 오픈 파일 테이블에 복사된다.
		- 이 테이블은 FCB와 파일을 연 프로세스의 수도 추적한다.
	3. 범 시스템 오픈 파일 테이블의 항목을 가리키는 포인터와 기타 필드를 갖는 새로운 항목이 프로세스별 오픈 파일 테이블 안에 만들어진다.
		- 이 필드들은 파일 안의 현재 위치를 가리키는 포인터와 파일이 열린 접근 모드 등을 포함한다.
4. open은 프로세스별 파일 시스템 테이블 내의 해당 항목에 대한 포인터를 반환한다.
5. 이후 모든 파일 연산은 이 포인터를 통해 실행된다.

파일을 닫는 close()가 호출되면

1. 프로세스별 테이블 항목이 제거되며, 범 시스템 항목의 오픈 계수는 감소된다.
2. 열렸던 모든 사용자가 파일을 닫으면(계수가 0이 되면) 디스크 기반 디렉터리 구조에 업데이트된 파일 정보가 복사되며 범 시스템 오픈 파일 테이블에서 그 항목이 삭제된다.

	

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_03_FileSystemStructures.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_03_FileSystemStructures.jpg)

## 11.2.2 파티션과 마운팅

파티션은 파일 시스템이 포함된 볼륨과 raw 디스크로 나눌 수 있다.

부트 로더는 통상 일련의 순차 블록으로 메모리에 하나의 이미지로 로드된다.

- 첫 번째 바이트와 같이 미리 정해진 위치에서 시작되며
- 파일 시스템의 구조를 알고 있어 커널의 위치를 찾아 적재하고 실행할 수 있다.

루트 파티션은 운영체제 커널과 더불어 다른 시스템 파일을 포함하고 있으며 부트 시에 마운트 된다.

- 다른 파티션들은 자동/수동으로 마운트된다.

마운트할 때에 파일 시스템은 일관성을 체크한다.

- 시스템이 유효한 파일 시스템을 가지고 있는지 확인하고
- 디바이스 드라이버에게 디바이스 디렉터리를 읽도록 요청한다.
- 디렉터리가 유효한 포멧을 가졌는지 확인함으로써 일관성을 체크한다.
- 만약 문제가 있다면 바로 잡으려 한다.

대부분의 시스템은 메모리에 존재하는 마운트 테이블에 파일 시스템이 마운트 되었다는 사실과 파일 시스템의 타입을 기록한다.

## 11.2.3 가상 파일 시스템

- 유닉스의 가상 파일 시스템은 파일 시스템을 구현하기 위해 객체 지향적 접근을 제공한다.
- 서로 다른 파일 시스템 타입 간에 동일한 시스템 콜(혹은 API)을 사용할 수 있도록 기능을 제공한다.
	- 세부적인 구현 사항으로부터 기본 시스템 호출 기능을 격리시킨다.
	- 구현은 파일 시스템일수도 NFS 일수도 있다.
	- 이 API는 VFS 인터페이스이며, 각 파일에 종속되지 않는다.

파일 시스템의 구현은 세 가지 주요한 계층으로 구성된다.

1. 파일 시스템 인터페이스
	- 열기, 읽기, 쓰기, 닫기 호출과 파일 디스크립터에 기반을 둔 레이어
2. VFS 인터페이스
	- NFS는 VFS 인터페이스를 명확히 정의하여 파일 시스템의 일반적 연산을 구현과 분리시킨다.
	- 다른 형태의 파일 시스템을 지역적으로 마운트함으로써 투명한 접근이 되도록함
	- 파일을 네트워크 전체에서 고유하게 표현할 수 있는 기법을 제공
	- VFS는 vnode라 불리는 파일 표현 구조에 기반을 둔다. vnode는 네트워크 전체에서 유일한 파일에 대한 수치 지정자를 포함하고 있다. 네트워크 파일 시스템을 지원하려면 범 시스템 상에서 유일해야 한다.
	- VFS는 원격 파일과 로컬 파일을 구분하고, 로컬 파일들은 파일 시스템 타입에 따라 세부적으로 구분된다.
		- VFS는 특정 파일 시스템의 연산을 구동시킴으로써 파일 시스템 타입에 따라 로컬 요청을 처리
		- 원격 요청에 대해서는 NFS 프로토콜 프로시저를 호출
		- 파일 핸들은 관련된 vnode들로 구성되며, 프로시저에 인자로 전달된다.
3. 파일	시스템 타입이나 원격 파일 시스템 프로토콜을 구현하는 계층은 최하부이다.

Linux의 VFS에서는 4가지 기본 객체를 정의한다.

- inode(각 파일), file(열린 파일), superblock(전체 파일 시스템), dentry(각 디렉터리 항목)

네 가지 객체 타입 각각에 대해 VFS는 구현되야 할 연산의 집합을 정의한다.

- 각 유형의 모든 객체는 함수 테이블을 가리키는 포인터를 갖는다.
- open, read, write, nmap
	
![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_04_Virtual_FS.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_04_Virtual_FS.jpg)

## 11.3 디렉터리 구현

디렉터리 할당과 디렉터리 관리 알고리즘의 선택은 파일 시스템의 효율, 성능 및 신뢰성에 매우 큰 영향을 미친다.

## 11.3.1 선형 리스트

파일 이름과 데이터 블록을 가리키는 포인터들의 선형 리스트를 사용하는 것 

- 프로그램이 간단하다.
- 실행에 속도가 많이 소요된다
	- 순차적으로 접근하기 때문
	- 정렬해서 이진 트리를 적용하거나 B-Tree를 사용해 속도를 개선

## 11.3.2 해시 테이블

선형 리스트와 디렉터리 항목들이 저장되는 해시 데이터 구조를 함께 사용하는 방법

- 해시 테이블은 파일 이름으로부터 계산된 값을 받아 선형 리스트의 파일 이름을 가리키는 포인터를 반환한다.
- 충돌이 날 경우에 대한 처리가 필요
- 삽입과 삭제가 쉽다.

단점으로는

1. 해시 테이블이 고정된 크기를 가진다.
	- 데이터의 양이 늘어날때 크기가 변화시켜야 할 수도 있다.
	- 변화하지 않는 대안으로 체인 오버플로우 해시 테이블을 사용할 수 있다.
		- 충돌 시에 기존 항목의 연결 리스트에 추가한다.
		- 선형으로 리스트를 찾는 것보다는 빠를 것이다.


# 11.4 할당 방법

## 11.4.1 연속 할당

연속 할당 방식은 각 파일이 디스크 내에서 반드시 연속적인 공간을 차지하도록 할당한다.

- 대부분의 경우에 최고의 성능을 나타낸다
- 간단하다 - 시작 블록과 길이(블록의 개수)만 저장하면 된다.
- 순차 접근과 직접 접근 모두를 쉽게 지원할 수 있다.
- 문제점으로는 가용 공간을 찾기 어렵다는 것이 있다
- 동적 공간 할당 문제와 같이 최초 적합과 최적 적합이 일반적이고 효율적이다.
- 외부 단편화가 생긴다는 문제가 있다.
	- 전체 파일 시스템을 다른 디스크 또는 복사하는 방법으로 해결할 수 있지만 시간이 매우 오래 걸린다.
- 또한 파일을 위해 얼마나 많은 공간을 할당해야 할지를 결정하는 것이 어렵다.
	- 생성 시에는 필요한 공간을 알기 어렵다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_05_ContiguousAllocation.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_05_ContiguousAllocation.jpg)

### 익스텐드 기법

이런 단점을 극복하기 위해 익스텐드라는 기법을 사용한다.

- 어느 정도의 연속된 공간만 초기에 할당하고, 충분치 않으면 또 연속된 공간을 익스텐트라고 부르는 단위로 할당한다.
- 파일 블록들의 위치는 위치와 블록 수, 다음 익스텐드의 첫 블록을 가리키는 포인터로 기록된다.
- 익스텐드의 크기가 너무 클 경우에는 내부 단편화 문제가 발생할 수 있고,
- 다양한 크기의 익스텐드가 할당 반환을 계속했을 때 외부 단편화가 발생할 수 있다.

## 11.4.2 연결 할당

연결 할당에서 파일은 디스크 블록의 연결 리스트이고, 디스크 블록은 어느 곳에나 위치할 수 있다.

- 디렉터리는 파일의 첫 번째와 마지막 블록을 가리키는 포인터를 가진다.
- 각 블록은 다음 블록에 대한 포인털르 포함한다.

새 파일을 생성하려면 단순히 디렉터리 내에 새로운 항목을 만들면 된다.

- 각 디렉터리 항목은 파일의 첫 디스크 블록을 가리키는 포인터를 갖고 있다.
	-  처음에는 디스크 블록을 가리키는 포인터를 nil 값으로 표시하여 빈 파일을 나타낸다.
	-  크기 필드 또한 0으로 설정한다.
-  파일 쓰기가 일어나면 가용 블록을 할당받아 쓰기를 실행한 후 파일의 끝에 연결한다.
-  파일을 읽기 위해서는 블록에서 블록으로 포인터를 따라가면서 읽으면 된다.

장점

- 연결 할당의 경우 외부 단편화가 없고 가용 공간 리스트의 어떠한 가용 블록들이 할당되어도 무방하다.
- 파일 생성시 생성할 파일의 크기가 미리 지정될 필요가 없다.
	- 가용 블록이 있는 한 파일은 계속해서 커질 수 있다.
- 밀집화할 방법도 없다.

단점

- 순차 접근 방식에만 효과적이다.
	- 직접 접근 방식으로 하면 포인터를 따라가야 한다
- 포인터를 위한 공간이 필요하다.
- 신뢰성 문제가 있다
	- 포인터가 없어지거나 망가지면 그 이후가 유실된다.
	- 이를 해결하기 위해 이중 연결 리스트를 고려할 수 있지만 오버 헤드를 필요로 한다.

이 문제들을 해결하는 방법은 여러 블록들을 하나의 클러스터로 구성하여 클러스터 단위로 할당하는 것이다.

- 예를 들어 4블록을 하나의 클러스터로 정의하고 디스크에 대한 작업은 클러스터 단위로만 하는 것이다.
- 포인터가 차지하는 비율이 작아지고
- 디스크 처리량을 향상시킨다.(헤드 탐색 줄어듬)
- 가용 리스트 관리에 필요한 공간을 줄인다.

단점으로는

1. 내부 단편화가 증가한다.


![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_06_LinkedAllocation.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_06_LinkedAllocation.jpg)

연결할당의 변형으로는 파일 할당 테이블(FAT)을 사용하는 것이다.

- 각 볼륨의 시작 부분의 일부가 FAT로 사용된다.
- FAT 테이블은 각 디스크 블록마다 한 개의 항목을 가지고 있고 이 항목은 디스크 블록 번호를 인덱스로 삼아 찾는다.
- 각 항목은 다음 블록 번호를 가리킨다.
	- 미사용 블록은 0으로 표시한다.

- 디렉터리의 각 항목은 파일의 첫 번째 블록 번호를 저장한다
- 그 블록 번호가 인덱싱하는 FAT 테이블 항목은 파일의 다음 블록 번호를 가리킨다.
- 이 연결은 마지막 블록까지 계속되며 마지막 블록의 테이블 항은 파일의 끝을 나타내는 값을 가진다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_07_FAT_Table.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_07_FAT_Table.jpg)

FAT 할당 기법은 FAT가 캐시되지 않으면 상당한 수의 탐색을 유발할 수 있다.

디스크 헤드가 FAT의 정보를 읽어 임의의 블록의 위치를 알아낼 수 있기에 무작위 접근 시간이 개선된다. 

## 11.4.3 색인 할당

각 파일들은 디스크 블록 주소를 모아놓은 배열인 색인 블록을 가진다. 

- 색인 블록의 i번째 항목은 파일의 i번째 블록을 가리킨다.
- 디렉터리는 색인 블록의 주소를 가지고 있다.
- 색인 블록 항목에 있는 i번째 항목에서 포인터를 얻어서 그 블록을 읽는다.

파일이 생성될 때 인덱스 블록의 모든 포인터는 nil로 설정된다.

- i번째 블록이 처음 쓰이면, 가용 블록 관리자로부터 한 블록을 할당받아 그 주소를 인덱스 블록의 i번째 항에 기록한다.

색인 할당은 외부 단편화 없이 직접 접근을 만족한다.

- 그러나 일반적으로 연결 할당의 포인터 오버헤드보다는 공간의 낭비가 크다.
- 인덱스 할당의 경우 nil이 아닌 값이 존재하면 전체 인덱스 블록을 할당해야 한다.

색인 블록은 가급적 작은게 좋은데, 이를 위해 여러 기법들이 사용된다.

1. 연결 기법
	- 하나의 블록을 할당하고, 크기가 커지면 여러 개의 블록을 연결시킨다.
2. 다중 수준 색인
	- 1차 단계 인덱스 블록이 2차 단계 인덱스 블록의 집합을 가리키고, 그 2차 단계 인덱스 블록이 파일 블록을 가리키는 방식
	- 단계는 늘어날 수 있다.
3. 결합 기법
	- 인덱스 블록의 첫 15개 포인터를 파일의 인덱스에 유지시킨다.
	- 이중 12개는 직접 블록을 가리킨다.
	- 다음 3개의 포인터는 간접 블록을 가리킨다.
		- 첫번째는 단일 간접 블록
		- 두번째는 이중 간접 블록
		- 세번째는 삼중 간접 블록

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_09_UNIX_inode.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_09_UNIX_inode.jpg)

## 11.4.4 성능

파일 접근 타입에 따라 좋은 방법이 다르다.

- 연속 할당 방식은 순차적, 무작위 접근 모두에 좋다.
- 연결 할당의 경우 순차 접근에는 좋지만 직접 접근에는 비효율적이다.
- 몇몇 시스템은 연속 할당을 사용해 직접 접근 파일을, 연결 할당을 사용해 순차 접근 파일을 모두 지원하기도 한다.
- 색인 할당은 복잡하다.
	- 색인 블록이 메모리 내에 존재하면 직접 접근할 수 있다.
	- 색인 블록을 전부 상주 시키는 것은 불가능 하기 때문에 인덱스 블록을 읽어아 햔다는 점을 고려해야 한다.
	- 2~3중 인덱스 블록일 경우 더욱 속도를 고민해야 한다.
- 작은 파일의 경우 연속 할당, 파일이 커지면 색인 할당으로 전환하는 방식을 사용하는 시스템도 있다.

# 11.5 가용 공간의 관리

파일 시스템은 가용 공간 리스트를 관리한다.

## 11.5.1 비트 벡터

가용 공간 리스트는 흔히 비트 백터 혹은 비트 맵으로 구현한다.

- 각 블록은 1비트로 표현되고, 가용하면 1, 아니면 0이 된다.

첫 번째 가용 블록 또는 n개의 연속된 가용 블록들을 찾는 일이 간단하고 효율적이다.

- 워드 단위로 워드의 값이 0인지 아닌지 확인하고
- 0이 아닌 워드를 찾으면 1인 첫 비트를 찾는다. -> 이것이 가용 공간의 위치
- 블록 번호 = (워드의 비트 수) * (값이 0인 워드의 수) + 첫 번째 1비트의 변위

비트 벡터는 전체 벡터가 주 메모리에 유지되지 않으면 비효율적이다.

- 작은 디스크가 아니고 큰 디스크는 비트맵 용량이 많이 필요하다(1TB 기준 32GB 이상의 브ㅌ맵 필요)

## 11.5.2 연결 리스트

모든 가용 디스크 블록을 함께 연결하는 방법을 생각할 수 있다.

- 첫 번째 가용 블록을 가리키는 포인터를 디스크의 특별한 위치에 저장하고 메모리에 캐싱한다.
- 첫 번째 가용 블록은 다음 가용 블록을 가리키는 포인터를 가진다.

가용 블록 리스트를 순회하는 것이 상당한 입출력 시간을 필요로 하지만, 빈번한 일은 아니다.

- 통상 하나의 블록이 필요하기 때문

FAT 기법은 가용 블록 회계와 할당 자료 구조를 결합하여 사용한다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_10_LinkedList.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_10_LinkedList.jpg)

## 11.5.3 그룹핑

가용 리스트 방식의 변형으로 첫 번째 가용 블록 내에 n-1개의 블록 주소를 저장하는 방법이 있다.

- n번째 블록은 빈 블록 주소를 가지고 있는 가용 블록을 가리킨다.
- 연결 리스트 방법과는 달리 많은 수의 가용 블록 주소들을 쉽게 찾을 수 있다.

## 11.5.4 계수

일반적으로 여러 개의 연속적인 블록이 동시에 할당되고 반환된다는 이점을 이용하는 방법으로 연속 할당 알고리즘이나 클러스터링을 통해 할당할 때에 유용한 방법이다.

- 모든 블록을 추적하지 않고, 연속된 가용 블록의 첫 번째 주소와 개수만 유지한다.
- 공간을 저장하는 길이는 더 짧아지게 된다.
- B-Tree 방식으로 저장될 수 있다.
- 블록 할당의 extent 방법과 유사하다.

## 11.5.5 공간맵

- 메타 슬랩을 생성해 장치의 공간을 관리 가능한 크기의 덩어리로 나눈다.
- 가용 블록에 관한 정보를 저장하기 위해 계수 알고리즘을 사용하는데, 이 구조를 디스크에 기록하는 것이 아니라 로그-구조 파일 시스템 기법을 사용하여 저장한다.
- 공간맵은 할당과 반환의 모든 블록 활동을 계수 형식으로 시간 순서에 맞게 기록한다.
- ZFS가 메타 슬랩으로부터 공간을 할당하거나 반환하려고 할 때 관련된 공간맵을 변위에 따라 색인된 균형-트리 형태로 메모리에 적재하고 로그를 재 실행해 이 구조에 반영한다.
	- 메모리 내 공간 맵은 메타슬랩의 할당과 반환 상태를 정확히 표현하게 된다.
- 그리고 ZFS는 연속도니 가용 블록을 결합해 하나의 항으로 만든다.

본질적으로 로그와 균형 트리가 합쳐져 가용 리스트 역할을 하게 된다.

# 11.6 효율과 성능

## 11.6.1 효율

1. 디스크 할당 및 디렉토리 알고리즘 
	- 가령 클러스터링 + 내부단편화 + 파일 탐색 속도
2. 디렉토리 엔트리에 담는 정보의 종류(적을 수록 탐색이 줄어든다)
3. metadata 구조들을 미리 할당하거나 필요할 때 할당하는 방식
4. 고정되거나 변동되는 데이터 구조

## 11.6.2 성능

입출력이 동기적인지 비동기적인지도 성능에 영향을 미친다.

- 동기식 쓰기는 버퍼에 저장되지 않고 디스크로 쓰인다
	- 메타 데이터 쓰기 작업은 통상 동기식으로 실행한다.
- 비동기식 쓰기는 데이터를 캐시에 저장하고 호출자에게 제어를 돌려준다.

일부 시스템은 파일의 접근 타입(순차, 직접)에 따라 다른 교체 알고리즘을 사용한다.

- 순차 접근에서는 LRU 보다는 바로 제거(free-behind) 그리고 미리 읽기(read agead)로 알려진 기술을 사용해 최적화한다.

#### Page cache

- 버퍼 캐시 용으로 별도의 구역을 주 메모리에 유지하는 시스템도 있다
- 페이지 캐시는 가상 메모리 기법을 사용하여 파일 데이터를 페이지로써 캐싱한다.
- 이 두개를 통합한 통합 버퍼 캐시를 제공하는 시스템도 있다.
	- 이중 캐싱 문제를 피하기 위해서
	- 메모리 낭비이며, 두 캐시간의 일관성을 맞춰주어야 한다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_11_IO_wo_BufferCache.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_11_IO_wo_BufferCache.jpg)

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_12_UnifiedBufferCache.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_12_UnifiedBufferCache.jpg)

# 11.7 복구

시스템이 크래시 되면, 디렉터리 구조, 가용 블록 포인터, 가용 FCB 포인터와 같은 파일 시스템 자료 구조의 일관성이 깨질 수 있다.

캐시된 변경이 반영되기 전에 크래시가 발생하면 이 또한 문제가 될 수 있다.

## 11.7.1 일관성 검사

일관성 검사는 굉장히 오래 걸리며 부트 시마다 실행되어야 한다. 

- 대체 방안으로 파일 시스템은 파일 시스템 메타 데이터 안에 자신의 상태를 기록한다.
- 메타데이터 변경 시에 상태 비트를 표시하고, 갱신이 완료되면 0으로 설정한다.
- 만약 부트 시 상태 비트가 1이면 일관성 검사를 시작한다.

일관성 검사기는 디렉터리 구조에 있는 데이터와 디스크에 있는 데이터 블록을 비교하고 불일치가 발견되면 그것을 정정하려고 노력한다.

- 연결 할당이 사용되고 사용되고 모든 블록이 다음 블록에 대한 링크를 가지고 있다면, 데이터 블록으로부터 전체 파일, 디렉토리 구조를 재구축할 수 있다.
- 색인 할당 시스템에서는 디렉터리 항목을 잃으면 복구가 어렵다
	- 각 데이터 블록은 서로에 대한 정보를 가지고 있지 않다.
	- 이런 이유로 읽기를 위한 디렉터리 항목은 캐시하지만 메타데이터 변경을 유발하는 ㅅ데이터 쓰기는 동기식으로 실행한다.
	- 그래도 문제는 남아 있을 수 있다.

## 11.7.2 로그 구조 파일 시스템

로그 기반 트랜잭션 지향(또는 저널링) 파일 시스템은 일관성 검사 기법 이후 일관성을 복구하는데 도움을 준다

- 이 기법에서는 모든 트랜젝션을 로그에 작성한다.
	- 변경이 로그에 기록되면 commit된 것으로 간주한다
	- 로그 파일은 종종 원형 버퍼로 구현된다.
- 로그는 파일 시스템의 별도 섹션에 있을 수도 있고 별도 디스크에 있을 수도 있다.

시스템이 크레시되면 로그의 트랜잭션을 모두 완료하여 일관성을 유지하게 된다.

- commit된 트랜잭션은 완료시킨다(반영되지 않았을 수도 있다)
- 중단된 트랜잭션은 원상 복구해서 일관성을 유지한다.

## 11.7.4 백업과 복구

백업을 해두면 손실이 났을 때 백업 데이터로부터 복구만 하면 된다.

- 복사의 양을 최소화하기 위해 변화한 파일만 백업하면 된다
- 이를 점증적 백업이라 한다.


# 11.8 NFS

NFS는 LAN을 거쳐 원격 파일을 접근하기 위한 소프트웨어 시스템의 구현과 명세 모두를 말한다.

- 연결 네트워크에 따라 TCP, UDP 중 하나를 사용한다.

## 11.8.1 개요

NFS는 서로 연결된 워크스테이션의 집합을 독립적인 파일 시스템을 가진 독립적인 기계들의 집합으로 간주한다.

- NFS의 목적은 이들 파일 시스템들 사이에서 일정 수준의 공유를 투명하게 허용하는 것이다.
- 원격 디렉토리는 로컬 파일 시스템으로 마운트 된다.
	- 마운트 연산이 완료되면 마운트된 디렉터리는 로컬 파일 시스템의 서브트리처럼 보이게 되며 기존 서브트리를 대체한다.
	- 로컬 디렉터리는 마운트된 디렉터리의 루트명이 된다.
- 마운트 연산을 위해 전달되는 매개 변수로 원격 디렉터리를 지정하는 일은 투명하지 않은 방식으로 실행된다.
	- 원격 디렉터리의 위치가 반드시 제공되어야 한다.
	- 마운트 이후에는 시스템의 사용자는 원격 디렉터리에 존재하는 파일에 로컬 디렉터리에 존재하는 파일처럼 접근할 수 있다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_13_Independent_FS.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_13_Independent_FS.jpg)

일부 NFS 구현에서는 연속(cascading) 마운트도 허용된다.

- 즉 한 파일 시스템이 이미 원격 마운트된 파일 시스템에 다시 마운트될 수 있다.
- 하지만 클라이언트는 이미 마운트되어 있던 다른 파일 시스템에는 접근할 수 없다.
- 마운트 기법은 이행성 특성을 갖지 않는다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_14_NFS_Mounting.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_14_NFS_Mounting.jpg

NFS의 설계 목표 중 하나는 서로 다른 기계, 운영체제, 네트워크로 구성된 이질적 환경에서 작동하는 것이다.

- NFS 명세는 이들 매체에 독립적이기에 구현은 달라질 수 있다.
- NFS와 정확하게 인터페이스 되는 이기종 시스템과 파일 시스템으로 구성된 시스템에서는 다른 타입의 파일 시스템들도 로컬 또는 원격으로 마운트될 수 있다.

NFS 명세는 마운트 기법에 의해 제공되는 서비스와 실제 원격 파일 접근 서비스를 구분하며 다른 프로토콜을 명세하고 있다.

## 11.8.2 마운트 프로토콜

마운트 프로토콜은 서비스와 클라이언트 사이에 최초의 논리적 연결을 생성하기 위해서 사용된다.

- 마운트 연산은 마운트될 원격 디렉터리의 이름과 그것을 저장하고 있는 서버 기계의 이름을 포함한다.
- 마운트 요청은 적절한 RPC로 맵핑되고, 지명된 서버 기계 상에서 실행되는 마운트 서버로 전달된다.
- 서버는 export list를 유지하며, 이 목록은 마운트할 수 있도록 하는 로컬 파일 시스템을 지정하고, 이를 마운트하도록 허가받은 기계의 이름도 함께 명시한다.
	- 이 리스트는 접근 권한도 포함할 수 있다.

서버가 자신의 export list가 허용하는 마운트 요청을 받으면 클라이언트에게 향후 마운트된 파일 시스템 안의 파일에 접근할 때 키로 사용될 파일 핸들을 반환한다.

서버는 또한 클라이언트 시스템의 리스트와 각 시스템에 현재 마운트된 디렉터리를 유지한다.

- 주로 관리 목적이다.
- 서버 고장시 노티한다던지
- 이게 서버의 상태가 변경되는 유일한 지점이다.

## 11.8.3 NFS 프로토콜

NFS 프로토콜은 원격 파일 연산을 위한 원격 프로시저 호출의 집합을 제공한다.

1. 디렉터리 내의 파일 검색
2. 디렉터리 항목 집합 읽기
3. 링크와 디렉터리들의 조작
4. 파일 속성의 접근
5. 파일 읽기/쓰기

NFS 서비스는 무상태성을 주요 특징으로 하고 있다

- 따라서 open, close가 없다.
- 각각의 요청들은 적절한 동작을 위해서 파일 식별자와 파일 내부의 절대적인 변위와 같은 인자를 항상 제공해야 한다.
- 서버는 모든 NFS 데이터를 동기적으로 써야만 한다
	- 캐싱을 쓰지 못하기에 성능은 낮아진다.
- NFS 프로토콜은 concurrency-control mechanism을 제공하지 않는다.

NFS는 VFS를 통해 운영체제로 통합된다.

1. 클라이언트는 정규 시스템 콜로 연산을 시작한다.
2. 운영체제 층은 이 호출을 vnode에 대한 VFS 연산으로 맵핑한다
3. VFS는 이 파일을 원격 파일로 인식하고 적절한 NFS 프로시저를 실행한다
4. 원격 서버 내의 NFS 서비스 계층을 목적지로 RPC 호출을 한다.
5. 이 호출은 원격 시스템 상의 VFS 계층으로 다시 들어가고
6. 원격 시스템은 그 호출에 따라 파일 시스템 연산을 실행한다.
7. 그리고 결과를 반환하기 위해 경로를 되밟아간다.

이 구조의 장점을 모두가 클라이언트, 서버가 될 수 있다는 점이다.

![https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_15_NFS_Schematic.jpg](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_15_NFS_Schematic.jpg)

